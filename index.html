<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HubSpot Calling Widget </title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìû</text></svg>" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f4f4f4;
    }
    #widget-container {
      text-align: center;
      background: #ffffff;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      width: 400px;
      padding: 20px;
    }
    button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:disabled {
      background: #ddd;
      cursor: not-allowed;
    }
    .primary-button {
      background-color: #007bff;
      color: white;
    }
    .danger-button {
      background-color: #dc3545;
      color: white;
    }
    .success-button {
      background-color: #28a745;
      color: white;
    }
    .status-container {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
    }
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status-connected {
      background-color: #28a745;
    }
    .status-disconnected {
      background-color: #dc3545;
    }
    .status-pending {
      background-color: #ffc107;
    }
    .debug-log {
      margin-top: 20px;
      max-height: 150px;
      overflow-y: auto;
      text-align: left;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
      font-family: monospace;
      font-size: 12px;
    }
    .log-entry {
      margin: 2px 0;
    }
    .log-error {
      color: #dc3545;
    }
    .log-success {
      color: #28a745;
    }
    .log-info {
      color: #007bff;
    }
  /* Modal styles */
  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
  }

  .modal-content {
    background-color: #fff;
    margin: 15% auto;
    padding: 20px;
    border-radius: 8px;
    width: 80%;
    max-width: 500px;
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }

  .modal-header h3 {
    margin: 0;
  }

  .close {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }

  .close:hover {
    color: #000;
  }

  .modal-body {
    margin-bottom: 15px;
  }

  .modal-footer {
    display: flex;
    justify-content: flex-end;
  }

  /* Blinking animation for recording indicator */
  @keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
  }
  </style>
</head>
<body>
<div id="widget-container">
  <h1>HubSpot Calling Widget</h1>


  <p>Simulate calling actions using the buttons below:</p>
  <button id="login-btn" class="primary-button">Log In</button>
  <button id="logout-btn" class="primary-button danger-button" disabled>Log Out</button>
  <button id="outbound-btn" class="primary-button success-button">Outbound Call</button>
  <button id="teams-call-btn" class="primary-button success-button">Teams Call</button>
  <button id="incoming-btn" class="primary-button success-button">Incoming Call</button>
  <button id="answer-btn" class="primary-button success-button" disabled>Answer Call</button>
  <button id="end-btn" class="primary-button danger-button" disabled>End Call</button>
  <button id="resize-btn" class="primary-button">Resize Widget</button>
  <button id="test-connection-btn" class="primary-button">Test Connection V1.0</button>
  <button id="history-btn" class="primary-button">Call History</button>

  <!-- Call History View -->
  <div class="status-container" id="call-history-container" style="display: none; max-height: 300px; overflow-y: auto;">
    <h3>Call History</h3>
    <div id="call-history-list">
      <p>No call history available.</p>
    </div>
  </div>

  <!-- Recordings View -->
  <div class="status-container" id="recordings-container" style="display: none; max-height: 300px; overflow-y: auto;">
    <h3>Recordings</h3>
    <div id="recordings-list">
      <p>No recordings available.</p>
    </div>
    <button id="recordings-btn" class="primary-button">Show Recordings</button>
  </div>

  <!-- Status container for connectivity troubleshooting as specified in "Debug and Refine the Flow" section -->
  <div class="status-container">
    <h3>Connection Status</h3>
    <div>
      <span class="status-indicator status-pending" id="connection-status"></span>
      <span id="status-text">Initializing...</span>
    </div>
    <div>
      <p>Portal ID: <span id="portal-id">Not connected</span></p>
      <p>User ID: <span id="user-id">Not connected</span></p>
    </div>
  </div>

  <!-- Call status container for call management features -->
  <div class="status-container" id="call-status-container" style="display: none;">
    <h3>Call Status</h3>
    <div>
      <p>Status: <span id="call-status-text">No active call</span></p>
      <p>Duration: <span id="call-duration">00:00:00</span></p>
    </div>
    <div>
      <button id="mute-btn" class="primary-button" disabled>Mute</button>
      <button id="hold-btn" class="primary-button" disabled>Hold</button>
      <button id="transfer-btn" class="primary-button" disabled>Transfer</button>
    </div>

    <!-- Call recording controls -->
    <div style="margin-top: 10px; border-top: 1px solid #ddd; padding-top: 10px;">
      <button id="record-btn" class="primary-button danger-button" disabled>Start Recording</button>
      <span id="recording-status" style="margin-left: 10px; display: none;">
        <span style="color: red; animation: blink 1s infinite;">‚óè</span> Recording...
      </span>
    </div>

    <!-- Contact information display -->
    <div id="contact-info-display" style="margin-top: 15px; border-top: 1px solid #ddd; padding-top: 10px; display: none;">
      <h4>Contact Information</h4>
      <div id="contact-details">
        <p><strong>Name:</strong> <span id="contact-name">-</span></p>
        <p><strong>Company:</strong> <span id="contact-company">-</span></p>
        <p><strong>Phone:</strong> <span id="contact-phone">-</span></p>
        <p><strong>Email:</strong> <span id="contact-email">-</span></p>
      </div>
      <button id="add-notes-btn" class="primary-button" style="margin-top: 10px;">Add Notes</button>
    </div>
  </div>

  <!-- Debug log area for enhanced error handling as specified in "Debug and Refine the Flow" section -->
  <div class="debug-log" id="debug-log">
    <div class="log-entry log-info">Initializing HubSpot Calling Widget...</div>
  </div>
</div>

<!-- Call Notes Modal -->
<div id="notes-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Call Notes</h3>
      <span class="close" id="close-notes-modal">&times;</span>
    </div>
    <div class="modal-body">
      <p>Add notes about this call. These notes will be saved with the call record in HubSpot.</p>
      <textarea id="call-notes" rows="5" style="width: 100%; padding: 8px; margin-top: 10px;" placeholder="Enter your notes here..."></textarea>
    </div>
    <div class="modal-footer">
      <button id="save-notes-btn" class="primary-button success-button">Save Notes</button>
    </div>
  </div>
</div>

<!-- Outbound Call Modal -->
<div id="outbound-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Make Outbound Call</h3>
      <span class="close" id="close-outbound-modal">&times;</span>
    </div>
    <div class="modal-body">
      <p>Enter the phone number you want to call. The number should include the country code.</p>
      <input type="text" id="outbound-number" style="width: 100%; padding: 8px; margin-top: 10px;" placeholder="e.g. +61423662930 or 61423662930">
      <p style="margin-top: 10px; font-size: 12px; color: #666;">
        Phone numbers will be automatically formatted to E.164 format (with a leading + and only digits).
      </p>
    </div>
    <div class="modal-footer">
      <button id="dial-btn" class="primary-button success-button">Dial Number</button>
    </div>
  </div>
</div>

<!-- Teams Call Modal -->
<div id="teams-call-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Make Teams Call</h3>
      <span class="close" id="close-teams-call-modal">&times;</span>
    </div>
    <div class="modal-body">
      <p>Enter the phone number you want to call using Microsoft Teams. The number should include the country code.</p>
      <input type="text" id="teams-call-number" style="width: 100%; padding: 8px; margin-top: 10px;" placeholder="e.g. +61423662930 or 61423662930">
      <p style="margin-top: 10px; font-size: 12px; color: #666;">
        Phone numbers will be automatically formatted to E.164 format (with a leading + and only digits).
      </p>
    </div>
    <div class="modal-footer">
      <button id="teams-dial-btn" class="primary-button success-button">Call with Teams</button>
    </div>
  </div>
</div>

<!-- Load the HubSpot Calling Extensions SDK directly like the demo -->
<script src="https://cdn.jsdelivr.net/npm/@hubspot/calling-extensions-sdk@latest/dist/main.js"></script>
<!-- Load the SDK loader for fallback support and UUID library -->
<script src="sdk-loader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/uuid/dist/umd/uuidv4.min.js"></script>
<script>
  // Global unhandled promise rejection handler
  window.addEventListener('unhandledrejection', function(event) {
    // Check if it's a 404 error from the terminate endpoint
    const error = event.reason;
    if (error && error.message && error.message.includes('404') &&
        error.message.includes('terminate')) {
      console.log('[DEBUG_LOG] Caught unhandled promise rejection: Call termination API endpoint returned 404');
      console.log('[DEBUG_LOG] This may be due to API changes in HubSpot. The call has been ended locally.');

      // Prevent the default browser handling of the error
      event.preventDefault();
    } else {
      console.log('[DEBUG_LOG] Caught unhandled promise rejection:', error);
    }
  });
  // Initialize State
  const state = {
    userId: null,
    portalId: null,
    ownerId: null,
    externalCallId: null,
    toNumber: null,
    fromNumber: null, // Will be set from HubSpot in onReady event
    isConnected: false,
    connectionStatus: "pending", // pending, connected, disconnected
    callStartTime: null,
    callDuration: 0,
    callActive: false,
    callMuted: false,
    callOnHold: false,
    callTimer: null,
    currentContact: null,
    callNotes: "", // Store notes for the current call
    callHistory: [], // Store history of calls with notes,
    isRecording: false, // Track if recording is active
    recordingStartTime: null, // When recording started
    recordings: [] // Store recordings
  };

  // Debug logging function as specified in "Debug and Refine the Flow" section
  // logMessage function is already declared in sdk-loader.js
  logMessage = function(message, type = "info") {
    console.log(`[DEBUG_LOG] ${message}`);

    // Add to UI debug log
    const debugLog = document.getElementById("debug-log");
    const logEntry = document.createElement("div");
    logEntry.className = `log-entry log-${type}`;
    logEntry.textContent = message;
    debugLog.appendChild(logEntry);

    // Auto-scroll to bottom
    debugLog.scrollTop = debugLog.scrollHeight;
  }

  // Update connection status UI
  // updateConnectionStatus function is already declared in sdk-loader.js
  updateConnectionStatus = function(status, message) {
    const statusIndicator = document.getElementById("connection-status");
    const statusText = document.getElementById("status-text");
    const portalIdElement = document.getElementById("portal-id");
    const userIdElement = document.getElementById("user-id");

    // Remove all status classes
    statusIndicator.classList.remove("status-connected", "status-disconnected", "status-pending");

    // Add appropriate class
    statusIndicator.classList.add(`status-${status}`);

    // Update status text
    statusText.textContent = message;

    // Update state
    state.connectionStatus = status;
    state.isConnected = status === "connected";

    // Update IDs if connected
    if (status === "connected") {
      portalIdElement.textContent = state.portalId || "Unknown";
      userIdElement.textContent = state.userId || "Unknown";
    }
  }

  // Initialize Calling Extensions SDK using the SDK Loader
  // cti variable is already declared in sdk-loader.js

  // Configure the SDK initialization options
  const sdkOptions = {
    // Pass the logging and status update functions to the SDK loader
    logMessage: logMessage,
    updateConnectionStatus: updateConnectionStatus,

    // Configure the CTI options
    ctiOptions: {
      debugMode: true, // Enables debugging logs as required in HubSpot_App_v2.md
      eventHandlers: {
        onReady: ({ portalId, userId, ownerId } = {}) => {
          logMessage("HubSpot Calling Widget Ready", "success");
          logMessage(`Portal ID: ${portalId || 'Unknown'}`, "info");
          logMessage(`User ID: ${userId || 'Unknown'}`, "info");
          logMessage(`Owner ID: ${ownerId || 'Unknown'}`, "info");

          state.userId = userId || 0;
          state.portalId = portalId || 0;
          state.ownerId = ownerId || 0;

          // In a real implementation, you would make an API call to HubSpot to get the owner's phone number
          // using the ownerId. For now, we'll set a default value.
          // Example API call:
          // fetch(`https://api.hubspot.com/crm/v3/owners/${ownerId}`, {
          //   headers: { Authorization: `Bearer ${accessToken}` }
          // })
          // .then(response => response.json())
          // .then(data => {
          //   state.fromNumber = data.phoneNumber || "+1234567890";
          //   logMessage(`Owner's phone number set to ${state.fromNumber}`, "success");
          // })
          // .catch(error => {
          //   logMessage(`Failed to get owner's phone number: ${error.message}`, "error");
          //   state.fromNumber = "+1234567890"; // Fallback
          // });

          // For this demo, we'll set a default value
          state.fromNumber = "+6137105000";
          logMessage(`Owner's phone number set to ${state.fromNumber}`, "info");

          // Initialize the calling extension as specified in "Register and Associate Your Widget" section
          cti.initialized({
            isLoggedIn: false,
            isAvailable: false,
            sizeInfo: { width: 400, height: 650 },
          });

          // Update connection status
          updateConnectionStatus("connected", "Connected to HubSpot");
          logMessage("Calling extension initialized successfully", "success");
        },
        onError: (error) => {
          // Handle errors as specified in "Debug and Refine the Flow" section
          logMessage(`Error: ${error.message || 'Unknown error'}`, "error");
          updateConnectionStatus("disconnected", `Error: ${error.message || 'Unknown error'}`);

          // Troubleshooting guidance as specified in "Debug and Refine the Flow" section
          logMessage("Troubleshooting: Check widget URL, access token, and scopes", "error");
        },
        onDialNumber: (data) => {
          logMessage(`Dialing number: ${data.phoneNumber}`, "info");

          // Format the phone number to ensure it's in E.164 format
          let phoneNumber = data.phoneNumber;

          // Basic validation and formatting for phone numbers
          // Remove any non-digit characters except the leading +
          phoneNumber = phoneNumber.replace(/[^\d+]/g, '');

          // Ensure it starts with a + if it doesn't already
          if (!phoneNumber.startsWith('+')) {
            phoneNumber = '+' + phoneNumber;
          }

          logMessage(`Formatted phone number: ${phoneNumber}`, "info");
          state.toNumber = phoneNumber;

          // Handle outbound call as mentioned in "Debug and Refine the Flow" section
          const externalCallId = uuidv4();
          state.externalCallId = externalCallId;

          try {
            // Create engagement in HubSpot but reroute the actual call to Microsoft Teams
            // cti.outgoingCall({
            //   externalCallId: externalCallId,
            //   createEngagement: true, // Create engagement in HubSpot as required
            //   fromNumber: state.fromNumber,
            //   toNumber: phoneNumber, // Use the formatted phone number
            // });

            logMessage(`HubSpot engagement created for call to: ${phoneNumber}`, "success");

            // Start call timer to track call duration and update UI
            // startCallTimer();

            // Create Teams deep link URL
            // For PSTN calls, the format should be 4:<phonenumber> without the + prefix and country code
            let formattedPhoneNumber = phoneNumber.replace('+', '');
            // Remove the country code "61" if it's at the beginning of the number
            if (formattedPhoneNumber.startsWith('61')) {
              formattedPhoneNumber = formattedPhoneNumber.substring(2);
            }
            const teamsUrl = `https://teams.microsoft.com/l/call/0/0?users=4:${formattedPhoneNumber}`;
            logMessage(`Teams URL created: ${teamsUrl}`, "info");

            // Open the Teams URL in a dedicated window
            window.open(teamsUrl, '_blank');
            
            // openTeamsUrlSilently(teamsUrl);

            logMessage(`Teams call initiated to: ${phoneNumber}`, "success");
            enableButtons([endButton]);
          } catch (error) {
            logMessage(`Error initiating outbound call: ${error.message || 'Unknown error'}`, "error");
            // Handle the error gracefully
            updateConnectionStatus("connected", "Call initiation failed, but connection is still active");
          }
        },
        // Add additional event handlers as specified in "Debug and Refine the Flow" section
        onEngagementCreated: (data) => {
          logMessage(`Engagement created: ${JSON.stringify(data)}`, "success");

          // Verify engagements as specified in "Debug and Refine the Flow" section
          logMessage("Engagement should appear in Activity Feed for the contact", "info");
        },
        onEngagementFailed: (error) => {
          logMessage(`Engagement creation failed: ${error.message || 'Unknown error'}`, "error");

          // Troubleshooting guidance
          logMessage("Check CRM permissions and contact record access", "error");
        },
        onCallCompleted: (data) => {
          logMessage(`Call completed: ${JSON.stringify(data)}`, "success");
        },
        // Add handler for CREATE_ENGAGEMENT_SUCCEEDED event
        onCreateEngagementSucceeded: (data) => {
          logMessage(`Engagement creation succeeded: ${JSON.stringify(data)}`, "success");
          // You can add additional logic here if needed
        },
        // Add handler for INITIATE_CALL_ID_FAILED event
        onInitiateCallIdFailed: (error) => {
          logMessage(`Call ID initiation failed: ${JSON.stringify(error)}`, "error");

          // Update UI to reflect the failure
          updateConnectionStatus("connected", "Call initiation failed, but connection is still active");

          // Enable the appropriate buttons
          disableButtons([endButton]);
          enableButtons([incomingButton]);

          // Provide troubleshooting guidance
          logMessage("The call could not be initiated with HubSpot. This may be due to:", "error");
          logMessage("1. API rate limits being exceeded", "error");
          logMessage("2. Invalid phone number format", "error");
          logMessage("3. Server-side issues at HubSpot", "error");
          logMessage("The engagement was still created successfully.", "info");
        },
        // Add handler for OUTGOINGCALL event
        onOutgoingCall: (data) => {
          logMessage(`Outgoing call event received: ${JSON.stringify(data)}`, "info");

          // Extract call information from the event data
          const { toNumber, fromNumber, externalCallId } = data;

          // Update state with call information
          state.toNumber = toNumber;
          state.fromNumber = fromNumber || state.fromNumber;
          state.externalCallId = externalCallId;

          logMessage(`Handling outgoing call to: ${toNumber}`, "success");

          // Update UI to reflect the active call
          updateConnectionStatus("connected", "Call in progress");

          // Enable the appropriate buttons for an active call
          enableButtons([endButton]);
          disableButtons([incomingButton]);

          // Start call timer
          startCallTimer();

          // Return a response to HubSpot to acknowledge the event
          return {
            success: true
          };
        },
      },
    }
  };

  // Initialize the SDK directly like the demo
  try {
    // Access the SDK via window.default like in the demo
    const CallingExtensions = window.default;

    if (CallingExtensions) {
      // Create the CTI instance directly
      cti = new CallingExtensions(sdkOptions.ctiOptions);

      // Ensure Constants is properly initialized
      if (window.Constants) {
        cti.Constants = window.Constants;
        logMessage("Constants initialized successfully", "success");
      } else {
        logMessage("Constants not found in window, some features may not work correctly", "warning");
      }

      logMessage("SDK initialized successfully using direct initialization", "success");
    } else {
      // If direct initialization fails, fall back to the SDK Loader
      logMessage("Direct initialization failed, falling back to SDK Loader", "warning");
      window.HubSpotSDKLoader.initializeSDK(sdkOptions)
        .then(ctiInstance => {
          // Store the cti instance for use throughout the code
          cti = ctiInstance;
          logMessage("SDK initialized successfully using SDK Loader", "success");
        })
        .catch(error => {
          logMessage(`Failed to initialize SDK: ${error.message}`, "error");
          updateConnectionStatus("disconnected", "Failed to initialize SDK");
        });
    }
  } catch (error) {
    logMessage(`Error during direct initialization: ${error.message}`, "error");

    // Fall back to the SDK Loader
    logMessage("Falling back to SDK Loader", "warning");
    window.HubSpotSDKLoader.initializeSDK(sdkOptions)
      .then(ctiInstance => {
        // Store the cti instance for use throughout the code
        cti = ctiInstance;

        // Double-check Constants initialization in fallback path
        if (!cti.Constants && window.Constants) {
          cti.Constants = window.Constants;
          logMessage("Constants initialized in fallback path", "success");
        }

        logMessage("SDK initialized successfully using SDK Loader", "success");
      })
      .catch(fallbackError => {
        logMessage(`Failed to initialize SDK with fallback: ${fallbackError.message}`, "error");
        updateConnectionStatus("disconnected", "Failed to initialize SDK");
      });
  }

  // Call Management Functions

  // Button Actions
  const logInButton = document.getElementById("login-btn");
  const logOutButton = document.getElementById("logout-btn");
  const outboundButton = document.getElementById("outbound-btn");
  const teamsCallButton = document.getElementById("teams-call-btn");
  const incomingButton = document.getElementById("incoming-btn");
  const answerButton = document.getElementById("answer-btn");
  const endButton = document.getElementById("end-btn");
  const resizeButton = document.getElementById("resize-btn");
  const testConnectionButton = document.getElementById("test-connection-btn");
  const muteButton = document.getElementById("mute-btn");
  const holdButton = document.getElementById("hold-btn");
  const transferButton = document.getElementById("transfer-btn");
  const contactInfoDisplay = document.getElementById("contact-info-display");
  const contactName = document.getElementById("contact-name");
  const contactCompany = document.getElementById("contact-company");
  const contactPhone = document.getElementById("contact-phone");
  const contactEmail = document.getElementById("contact-email");
  const addNotesButton = document.getElementById("add-notes-btn");

  // Notes modal elements
  const notesModal = document.getElementById("notes-modal");
  const closeNotesModalBtn = document.getElementById("close-notes-modal");
  const callNotesTextarea = document.getElementById("call-notes");
  const saveNotesButton = document.getElementById("save-notes-btn");

  // Outbound call modal elements
  const outboundModal = document.getElementById("outbound-modal");
  const closeOutboundModalBtn = document.getElementById("close-outbound-modal");
  const outboundNumberInput = document.getElementById("outbound-number");
  const dialButton = document.getElementById("dial-btn");

  // Teams call modal elements
  const teamsCallModal = document.getElementById("teams-call-modal");
  const closeTeamsCallModalBtn = document.getElementById("close-teams-call-modal");
  const teamsCallNumberInput = document.getElementById("teams-call-number");
  const teamsDialButton = document.getElementById("teams-dial-btn");

  // Call history elements
  const historyButton = document.getElementById("history-btn");
  const callHistoryContainer = document.getElementById("call-history-container");
  const callHistoryList = document.getElementById("call-history-list");

  // Recording elements
  const recordButton = document.getElementById("record-btn");
  const recordingStatus = document.getElementById("recording-status");

  // Recordings view elements
  const recordingsContainer = document.getElementById("recordings-container");
  const recordingsList = document.getElementById("recordings-list");
  const recordingsButton = document.getElementById("recordings-btn");

  logInButton.addEventListener("click", () => {
    try {
      cti.userLoggedIn();
      logMessage("User Logged In", "success");
      updateConnectionStatus("connected", "User logged in");
      disableButtons([logInButton]);
      enableButtons([logOutButton, outboundButton, teamsCallButton, incomingButton]);
    } catch (error) {
      logMessage(`Error logging in: ${error.message || 'Unknown error'}`, "error");
      // Handle the error gracefully
      updateConnectionStatus("disconnected", "Login failed");
    }
  });

  logOutButton.addEventListener("click", () => {
    try {
      cti.userLoggedOut();
      logMessage("User Logged Out", "info");
      updateConnectionStatus("disconnected", "User logged out");
      disableButtons([logOutButton, outboundButton, teamsCallButton, incomingButton, answerButton, endButton]);
      enableButtons([logInButton]);
    } catch (error) {
      logMessage(`Error logging out: ${error.message || 'Unknown error'}`, "error");
      // Handle the error gracefully
      updateConnectionStatus("connected", "Logout failed, but connection is still active");
    }
  });

  // Format phone number to E.164 format
  function formatPhoneNumber(rawNumber) {
    // Format the phone number to ensure it's in E.164 format
    let phoneNumber = rawNumber;

    // Basic validation and formatting for phone numbers
    // Remove any non-digit characters except the leading +
    phoneNumber = phoneNumber.replace(/[^\d+]/g, '');

    // Ensure it starts with a + if it doesn't already
    if (!phoneNumber.startsWith('+')) {
      phoneNumber = '+' + phoneNumber;
    }

    return phoneNumber;
  }

  // Outbound call button event listener
  outboundButton.addEventListener("click", () => {
    // Show the outbound call modal
    outboundModal.style.display = "block";

    // Focus the input field
    outboundNumberInput.focus();

    logMessage("Outbound call modal opened", "info");
  });

  // Close outbound modal button event listener
  closeOutboundModalBtn.addEventListener("click", () => {
    outboundModal.style.display = "none";
    logMessage("Outbound call modal closed", "info");
  });

  // Dial button event listener
  dialButton.addEventListener("click", () => {
    const rawNumber = outboundNumberInput.value.trim();

    if (!rawNumber) {
      logMessage("Please enter a phone number", "error");
      return;
    }

    logMessage(`Dialing number: ${rawNumber}`, "info");

    try {
      // Format the phone number
      const phoneNumber = formatPhoneNumber(rawNumber);
      logMessage(`Formatted phone number: ${phoneNumber}`, "info");
      state.toNumber = phoneNumber;

      // Generate call ID
      state.externalCallId = uuidv4();
      logMessage(`Generated call ID: ${state.externalCallId}`, "info");

      // Close the modal
      outboundModal.style.display = "none";

      // Initiate outbound call
      try {
        cti.outgoingCall({
          externalCallId: state.externalCallId,
          createEngagement: true,
          fromNumber: state.fromNumber,
          toNumber: phoneNumber,
        });

        logMessage(`Outbound call initiated to: ${phoneNumber}`, "success");
        enableButtons([endButton]);
        disableButtons([outboundButton, incomingButton]);

        // Start call timer when call is initiated
        startCallTimer();
      } catch (error) {
        logMessage(`Error initiating outbound call: ${error.message || 'Unknown error'}`, "error");
        updateConnectionStatus("connected", "Call initiation failed, but connection is still active");
      }
    } catch (error) {
      logMessage(`Error in dial process: ${error.message}`, "error");
    }
  });

  // Teams call button event listener
  teamsCallButton.addEventListener("click", () => {
    // Show the Teams call modal
    teamsCallModal.style.display = "block";

    // Pre-populate the input field with the number from onDialNumber if available
    if (state.toNumber) {
      teamsCallNumberInput.value = state.toNumber;
      logMessage(`Pre-populated Teams call number with: ${state.toNumber}`, "info");
    }

    // Focus the input field
    teamsCallNumberInput.focus();

    logMessage("Teams call modal opened", "info");
  });

  // Close Teams call modal button event listener
  closeTeamsCallModalBtn.addEventListener("click", () => {
    teamsCallModal.style.display = "none";
    logMessage("Teams call modal closed", "info");
  });

  // Teams dial button event listener
  teamsDialButton.addEventListener("click", () => {
    const rawNumber = teamsCallNumberInput.value.trim();

    if (!rawNumber) {
      logMessage("Please enter a phone number", "error");
      return;
    }

    logMessage(`Initiating Teams call to: ${rawNumber}`, "info");

    try {
      // Format the phone number
      const phoneNumber = formatPhoneNumber(rawNumber);
      logMessage(`Formatted phone number: ${phoneNumber}`, "info");

      // Create Teams deep link URL
      // For PSTN calls, the format should be 4:<phonenumber> without the + prefix and country code
      let formattedPhoneNumber = phoneNumber.replace('+', '');
      // Remove the country code "61" if it's at the beginning of the number
      if (formattedPhoneNumber.startsWith('61')) {
        formattedPhoneNumber = formattedPhoneNumber.substring(2);
      }
      const teamsUrl = `https://teams.microsoft.com/l/call/0/0?users=4:${formattedPhoneNumber}`;
      logMessage(`Teams URL created: ${teamsUrl}`, "info");

      // Close the modal
      teamsCallModal.style.display = "none";

      window.open(teamsUrl, '_blank');
      // Open the Teams URL in a dedicated window
      // openTeamsUrlSilently(teamsUrl);

      logMessage(`Teams call initiated to: ${phoneNumber}`, "success");
    } catch (error) {
      logMessage(`Error initiating Teams call: ${error.message}`, "error");
    }
  });

  // Close modal when clicking outside of it
  window.addEventListener("click", (event) => {
    if (event.target === outboundModal) {
      outboundModal.style.display = "none";
    } else if (event.target === teamsCallModal) {
      teamsCallModal.style.display = "none";
    }
  });

  incomingButton.addEventListener("click", () => {
    state.externalCallId = uuidv4(); // Generate unique call ID
    state.toNumber = "+9876543210"; // Example called number

    logMessage(`Simulating incoming call from ${state.fromNumber} to ${state.toNumber}`, "info");

    cti.incomingCall({
      externalCallId: state.externalCallId,
      createEngagement: true, // Log the call in HubSpot as required in "Debug and Refine the Flow" section
      fromNumber: state.fromNumber,
      toNumber: state.toNumber,
    });

    logMessage("Incoming call sent to HubSpot...", "success");
    enableButtons([answerButton]);
    disableButtons([incomingButton]);
  });

  answerButton.addEventListener("click", () => {
    try {
      cti.callAnswered({
        externalCallId: state.externalCallId,
      });
      logMessage("Call answered", "success");
      enableButtons([endButton]);
      disableButtons([answerButton]);

      // Start call timer when call is answered
      startCallTimer();
    } catch (error) {
      logMessage(`Error answering call: ${error.message || 'Unknown error'}`, "error");
      // Handle the error gracefully
      updateConnectionStatus("connected", "Call answer failed, but connection is still active");
    }
  });

  endButton.addEventListener("click", () => {
    // Define a fallback value for callEndStatus if cti.Constants is undefined
    const callEndStatus = cti.Constants && cti.Constants.callEndStatus
      ? cti.Constants.callEndStatus.INTERNAL_COMPLETED
      : "COMPLETED"; // Fallback value if Constants is undefined

    // Call the callEnded method with error handling
    try {
      const callEndPromise = cti.callEnded({
        externalCallId: state.externalCallId,
        callEndStatus: callEndStatus,
      });

      // Add error handling for the promise
      if (callEndPromise && typeof callEndPromise.catch === 'function') {
        callEndPromise.catch(error => {
          // Check if it's a 404 error from the terminate endpoint
          if (error && error.message && error.message.includes('404') &&
              error.message.includes('terminate')) {
            logMessage("Warning: Call termination API endpoint returned 404. This may be due to API changes.", "warning");
            logMessage("The call has been ended locally, but HubSpot may not have been notified properly.", "warning");
            logMessage("This won't affect your ability to make or receive calls.", "info");
          } else {
            logMessage(`Error ending call: ${error.message || 'Unknown error'}`, "error");
          }
        });
      }
    } catch (error) {
      logMessage(`Error calling callEnded method: ${error.message || 'Unknown error'}`, "error");
    }

    logMessage("Call ended", "info");
    logMessage("Verifying engagement creation in HubSpot...", "info");
    disableButtons([endButton]);
    enableButtons([outboundButton, incomingButton]);

    // Stop call timer when call ends
    stopCallTimer();
  });

  // Call management button event listeners
  muteButton.addEventListener("click", toggleMute);
  holdButton.addEventListener("click", toggleHold);
  transferButton.addEventListener("click", transferCall);

  // Recording Functions

  // Toggle recording
  function toggleRecording() {
    if (!state.callActive) {
      logMessage("Cannot record: No active call", "error");
      return;
    }

    if (state.isRecording) {
      stopRecording();
    } else {
      startRecording();
    }
  }

  // Start recording
  function startRecording() {
    state.isRecording = true;
    state.recordingStartTime = new Date();

    // Update UI
    recordButton.textContent = "Stop Recording";
    recordingStatus.style.display = "inline";

    logMessage("Call recording started", "success");

    // In a real implementation, you would start the actual recording here
    // For this demo, we'll just simulate it
  }

  // Stop recording
  function stopRecording() {
    if (!state.isRecording) return;

    const recordingEndTime = new Date();
    const recordingDuration = Math.floor((recordingEndTime - state.recordingStartTime) / 1000); // in seconds

    // Create recording object
    const recording = {
      id: uuidv4(),
      callId: state.externalCallId,
      startTime: state.recordingStartTime.toISOString(),
      endTime: recordingEndTime.toISOString(),
      duration: recordingDuration,
      contact: state.currentContact ? {
        id: state.currentContact.id,
        name: `${state.currentContact.firstName} ${state.currentContact.lastName}`,
        phone: state.currentContact.phone
      } : null,
      // In a real implementation, you would include the actual recording data or a URL
      url: `recording_${Date.now()}.mp3` // Simulated URL
    };

    // Add to recordings array
    state.recordings.push(recording);

    // Reset recording state
    state.isRecording = false;
    state.recordingStartTime = null;

    // Update UI
    recordButton.textContent = "Start Recording";
    recordingStatus.style.display = "none";

    logMessage(`Call recording stopped (${formatDuration(recordingDuration)})`, "success");

    // In a real implementation, you would stop the actual recording here
    // For this demo, we'll just simulate it
  }

  // Recordings Functions

  // Toggle recordings view
  function toggleRecordings() {
    const isVisible = recordingsContainer.style.display !== 'none';

    if (isVisible) {
      recordingsContainer.style.display = 'none';
      recordingsButton.textContent = 'Show Recordings';
      logMessage("Recordings hidden", "info");
    } else {
      updateRecordingsList();
      recordingsContainer.style.display = 'block';
      recordingsButton.textContent = 'Hide Recordings';
      logMessage("Recordings displayed", "info");
    }
  }

  // Update recordings list
  function updateRecordingsList() {
    // Clear the list
    recordingsList.innerHTML = '';

    if (state.recordings.length === 0) {
      recordingsList.innerHTML = '<p>No recordings available.</p>';
      return;
    }

    // Create a list of recordings
    const recordingsTable = document.createElement('table');
    recordingsTable.style.width = '100%';
    recordingsTable.style.borderCollapse = 'collapse';

    // Add table header
    const tableHeader = document.createElement('thead');
    tableHeader.innerHTML = `
      <tr style="background-color: #f0f0f0; text-align: left;">
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Date/Time</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Contact</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Duration</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Actions</th>
      </tr>
    `;
    recordingsTable.appendChild(tableHeader);

    // Add table body
    const tableBody = document.createElement('tbody');

    state.recordings.forEach(recording => {
      const row = document.createElement('tr');
      row.style.borderBottom = '1px solid #ddd';

      // Format date
      const date = new Date(recording.startTime);
      const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;

      // Format duration
      const formattedDuration = formatDuration(recording.duration);

      // Format contact name
      const contactName = recording.contact ? recording.contact.name : 'Unknown';

      // Create row cells
      const dateCell = document.createElement('td');
      dateCell.style.padding = '8px';
      dateCell.textContent = formattedDate;

      const contactCell = document.createElement('td');
      contactCell.style.padding = '8px';
      contactCell.textContent = contactName;

      const durationCell = document.createElement('td');
      durationCell.style.padding = '8px';
      durationCell.textContent = formattedDuration;

      const actionsCell = document.createElement('td');
      actionsCell.style.padding = '8px';

      // Create play button
      const playButton = document.createElement('button');
      playButton.className = 'primary-button success-button';
      playButton.style.padding = '5px 10px';
      playButton.style.fontSize = '12px';
      playButton.textContent = 'Play';
      playButton.onclick = () => {
        playRecording(recording);
      };

      // Create download button
      const downloadButton = document.createElement('button');
      downloadButton.className = 'primary-button';
      downloadButton.style.padding = '5px 10px';
      downloadButton.style.fontSize = '12px';
      downloadButton.style.marginLeft = '5px';
      downloadButton.textContent = 'Download';
      downloadButton.onclick = () => {
        downloadRecording(recording);
      };

      // Add buttons to actions cell
      actionsCell.appendChild(playButton);
      actionsCell.appendChild(downloadButton);

      // Add cells to row
      row.appendChild(dateCell);
      row.appendChild(contactCell);
      row.appendChild(durationCell);
      row.appendChild(actionsCell);

      tableBody.appendChild(row);
    });

    recordingsTable.appendChild(tableBody);
    recordingsList.appendChild(recordingsTable);
  }

  // Play recording
  function playRecording(recording) {
    logMessage(`Playing recording from ${new Date(recording.startTime).toLocaleString()}`, "info");

    // In a real implementation, you would play the actual recording
    // For this demo, we'll just simulate it with an alert
    alert(`Playing recording: ${recording.url}\nDuration: ${formatDuration(recording.duration)}\nContact: ${recording.contact ? recording.contact.name : 'Unknown'}`);
  }

  // Download recording
  function downloadRecording(recording) {
    logMessage(`Downloading recording from ${new Date(recording.startTime).toLocaleString()}`, "info");

    // In a real implementation, you would download the actual recording
    // For this demo, we'll just simulate it with an alert
    alert(`Downloading recording: ${recording.url}\nDuration: ${formatDuration(recording.duration)}\nContact: ${recording.contact ? recording.contact.name : 'Unknown'}`);
  }

  // Call History Functions

  // Toggle call history view
  function toggleCallHistory() {
    const isVisible = callHistoryContainer.style.display !== 'none';

    if (isVisible) {
      callHistoryContainer.style.display = 'none';
      logMessage("Call history hidden", "info");
    } else {
      updateCallHistoryList();
      callHistoryContainer.style.display = 'block';
      logMessage("Call history displayed", "info");
    }
  }

  // Update call history list
  function updateCallHistoryList() {
    // Clear the list
    callHistoryList.innerHTML = '';

    if (state.callHistory.length === 0) {
      callHistoryList.innerHTML = '<p>No call history available.</p>';
      return;
    }

    // Create a list of calls
    const historyTable = document.createElement('table');
    historyTable.style.width = '100%';
    historyTable.style.borderCollapse = 'collapse';

    // Add table header
    const tableHeader = document.createElement('thead');
    tableHeader.innerHTML = `
      <tr style="background-color: #f0f0f0; text-align: left;">
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Date/Time</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Contact</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Number</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Duration</th>
        <th style="padding: 8px; border-bottom: 1px solid #ddd;">Notes</th>
      </tr>
    `;
    historyTable.appendChild(tableHeader);

    // Add table body
    const tableBody = document.createElement('tbody');

    state.callHistory.forEach(call => {
      const row = document.createElement('tr');
      row.style.borderBottom = '1px solid #ddd';

      // Format date
      const date = new Date(call.timestamp);
      const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;

      // Format duration
      const formattedDuration = formatDuration(call.duration);

      // Format contact name
      const contactName = call.contact ? call.contact.name : 'Unknown';

      // Format phone number
      const phoneNumber = call.toNumber || call.fromNumber || 'Unknown';

      // Format notes (truncate if too long)
      const notes = call.notes ?
        (call.notes.length > 50 ? call.notes.substring(0, 50) + '...' : call.notes) :
        'No notes';

      // Create row cells
      row.innerHTML = `
        <td style="padding: 8px;">${formattedDate}</td>
        <td style="padding: 8px;">${contactName}</td>
        <td style="padding: 8px;">${phoneNumber}</td>
        <td style="padding: 8px;">${formattedDuration}</td>
        <td style="padding: 8px;">${notes}</td>
      `;

      // Add click event to show full notes if available
      if (call.notes) {
        row.style.cursor = 'pointer';
        row.title = 'Click to view full notes';
        row.onclick = () => {
          alert(`Call Notes:\n\n${call.notes}`);
        };
      }

      tableBody.appendChild(row);
    });

    historyTable.appendChild(tableBody);
    callHistoryList.appendChild(historyTable);
  }

  // Notes Modal Functions

  // Open the notes modal
  function openNotesModal() {
    if (!state.callActive) {
      logMessage("Cannot add notes: No active call", "error");
      return;
    }

    // Set the textarea value to the current notes
    callNotesTextarea.value = state.callNotes;

    // Show the modal
    notesModal.style.display = "block";

    // Focus the textarea
    callNotesTextarea.focus();

    logMessage("Notes modal opened", "info");
  }

  // Close the notes modal
  function closeNotesModal() {
    notesModal.style.display = "none";
    logMessage("Notes modal closed", "info");
  }

  // Save call notes
  function saveCallNotes() {
    const notes = callNotesTextarea.value.trim();

    // Update the state
    state.callNotes = notes;

    // Close the modal
    closeNotesModal();

    if (notes) {
      logMessage("Call notes saved", "success");
    } else {
      logMessage("Call notes cleared", "info");
    }
  }


  // Notes modal event listeners
  addNotesButton.addEventListener("click", openNotesModal);
  closeNotesModalBtn.addEventListener("click", closeNotesModal);
  saveNotesButton.addEventListener("click", saveCallNotes);

  // Close modal when clicking outside of it
  window.addEventListener("click", (event) => {
    if (event.target === notesModal) {
      closeNotesModal();
    }
  });

  // Call history button event listener
  historyButton.addEventListener("click", toggleCallHistory);

  // Record button event listener
  recordButton.addEventListener("click", toggleRecording);

  // Recordings button event listener
  recordingsButton.addEventListener("click", toggleRecordings);

  resizeButton.addEventListener("click", () => {
    cti.resizeWidget({
      width: 500,
      height: 700,
    });
    logMessage("Widget resizedX", "info");
  });

  // Test Connection button functionality as specified in "Debug and Refine the Flow" section
  testConnectionButton.addEventListener("click", () => {
    logMessage("Testing connection to HubSpot...", "info");
    updateConnectionStatus("pending", "Testing connection...");

    // Simulate connection test
    setTimeout(() => {
      try {
        // Check if SDK is initialized
        if (!cti) {
          throw new Error("Calling Extensions SDK not initialized");
        }

        // Test connection by sending a ping
        cti.initialized({
          isLoggedIn: state.isConnected,
          isAvailable: true,
          sizeInfo: { width: 400, height: 650 },
        });

        // Verify connectivity troubleshooting as specified in "Debug and Refine the Flow" section
        logMessage("Connection test successful", "success");
        logMessage("Widget URL setup is correct", "success");
        logMessage("SDK initialization successful", "success");
        updateConnectionStatus("connected", "Connection test successful");

        // Display troubleshooting guidance
        if (state.portalId && state.userId) {
          logMessage(`Connected to Portal ID: ${state.portalId}`, "info");
          logMessage(`Connected as User ID: ${state.userId}`, "info");
        } else {
          logMessage("Warning: Portal ID or User ID not available", "error");
          logMessage("Check HubSpot authentication and permissions", "error");
        }
      } catch (error) {
        logMessage(`Connection test failed: ${error.message}`, "error");
        updateConnectionStatus("disconnected", "Connection test failed");

        // Troubleshooting guidance
        logMessage("Troubleshooting steps:", "error");
        logMessage("1. Verify widget URL is correctly set up", "error");
        logMessage("2. Check access token validity", "error");
        logMessage("3. Verify proper scopes in private app", "error");
      }
    }, 1000); // Simulate network delay
  });

  // Call Management Functions

  // Format seconds to HH:MM:SS
  function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    return [
      hours.toString().padStart(2, '0'),
      minutes.toString().padStart(2, '0'),
      secs.toString().padStart(2, '0')
    ].join(':');
  }

  // Display contact information
  function displayContactInfo(contact) {
    if (!contact) {
      // If no contact is provided, hide the contact info display
      contactInfoDisplay.style.display = 'none';
      return;
    }

    // Populate contact information
    contactName.textContent = `${contact.firstName} ${contact.lastName}`;
    contactCompany.textContent = contact.company || '-';
    contactPhone.textContent = contact.phone || '-';
    contactEmail.textContent = contact.email || '-';

    // Show the contact info display
    contactInfoDisplay.style.display = 'block';

    logMessage(`Displaying contact information for ${contact.firstName} ${contact.lastName}`, "info");
  }

  // Start call timer
  function startCallTimer() {
    // Reset duration and set start time
    state.callDuration = 0;
    state.callStartTime = new Date();
    state.callActive = true;

    // Show call status container
    document.getElementById('call-status-container').style.display = 'block';
    document.getElementById('call-status-text').textContent = 'Call in progress';
    document.getElementById('call-duration').textContent = '00:00:00';

    // Enable call management buttons
    enableButtons([
      document.getElementById('mute-btn'),
      document.getElementById('hold-btn'),
      document.getElementById('transfer-btn'),
      addNotesButton,
      recordButton
    ]);

    // Display contact information if available
    if (state.currentContact) {
      displayContactInfo(state.currentContact);
    } else {
      // For incoming calls without contact info, create a basic contact object
      const unknownContact = {
        firstName: "Unknown",
        lastName: "Caller",
        phone: state.fromNumber,
        email: "-",
        company: "-"
      };
      displayContactInfo(unknownContact);
    }

    // Start timer to update duration
    state.callTimer = setInterval(() => {
      state.callDuration++;
      document.getElementById('call-duration').textContent = formatDuration(state.callDuration);
    }, 1000);

    logMessage("Call timer started", "info");
  }

  // Stop call timer
  function stopCallTimer() {
    // Clear interval
    if (state.callTimer) {
      clearInterval(state.callTimer);
      state.callTimer = null;
    }

    // Stop recording if active
    if (state.isRecording) {
      stopRecording();
      logMessage("Recording stopped due to call end", "info");
    }

    // Save call to history if it was active
    if (state.callActive) {
      // Create call record
      const callRecord = {
        id: state.externalCallId,
        timestamp: new Date().toISOString(),
        duration: state.callDuration,
        fromNumber: state.fromNumber,
        toNumber: state.toNumber,
        notes: state.callNotes,
        contact: state.currentContact ? {
          id: state.currentContact.id,
          name: `${state.currentContact.firstName} ${state.currentContact.lastName}`,
          company: state.currentContact.company,
          phone: state.currentContact.phone,
          email: state.currentContact.email
        } : null
      };

      // Add to call history
      state.callHistory.unshift(callRecord); // Add to beginning of array

      // Limit history to 50 calls
      if (state.callHistory.length > 50) {
        state.callHistory.pop();
      }

      logMessage("Call saved to history", "success");

      // In a real implementation, you would send this to HubSpot
      // For this demo, we'll just log it
      console.log("Call record:", callRecord);
    }

    // Reset call state
    state.callActive = false;
    state.callMuted = false;
    state.callOnHold = false;
    state.callNotes = ""; // Clear notes for next call

    // Update UI
    document.getElementById('call-status-text').textContent = 'Call ended';

    // Disable call management buttons
    disableButtons([
      document.getElementById('mute-btn'),
      document.getElementById('hold-btn'),
      document.getElementById('transfer-btn'),
      addNotesButton
    ]);

    // Reset button text
    document.getElementById('mute-btn').textContent = 'Mute';
    document.getElementById('hold-btn').textContent = 'Hold';

    // Hide contact information
    contactInfoDisplay.style.display = 'none';

    // Hide call status container after a delay
    setTimeout(() => {
      document.getElementById('call-status-container').style.display = 'none';
    }, 3000);

    logMessage("Call timer stopped", "info");
  }

  // Toggle mute
  function toggleMute() {
    if (!state.callActive) return;

    state.callMuted = !state.callMuted;
    const muteButton = document.getElementById('mute-btn');

    if (state.callMuted) {
      muteButton.textContent = 'Unmute';
      document.getElementById('call-status-text').textContent = 'Call muted';
      logMessage("Call muted", "info");
    } else {
      muteButton.textContent = 'Mute';
      document.getElementById('call-status-text').textContent = state.callOnHold ? 'Call on hold' : 'Call in progress';
      logMessage("Call unmuted", "info");
    }
  }

  // Toggle hold
  function toggleHold() {
    if (!state.callActive) return;

    state.callOnHold = !state.callOnHold;
    const holdButton = document.getElementById('hold-btn');

    if (state.callOnHold) {
      holdButton.textContent = 'Resume';
      document.getElementById('call-status-text').textContent = 'Call on hold';
      logMessage("Call placed on hold", "info");
    } else {
      holdButton.textContent = 'Hold';
      document.getElementById('call-status-text').textContent = state.callMuted ? 'Call muted' : 'Call in progress';
      logMessage("Call resumed", "info");
    }
  }

  // Transfer call
  function transferCall() {
    if (!state.callActive) return;

    // Show transfer dialog
    const transferNumber = prompt("Enter number to transfer to:");

    if (transferNumber && transferNumber.trim() !== '') {
      logMessage(`Transferring call to ${transferNumber}...`, "info");

      // In a real implementation, you would call the appropriate API
      // For this demo, we'll just simulate a successful transfer

      // End the current call
      stopCallTimer();

      // Show success message
      logMessage(`Call transferred to ${transferNumber}`, "success");
    }
  }

  /**
   * Helper function to open Teams URL for calling
   *
   * This function creates a visible iframe to trigger the Microsoft Teams app.
   * The iframe remains visible until the user clicks the "Start Call" button in Teams
   * or manually closes it using the provided close button.
   * While Teams UI cannot be embedded in an iframe due to Content Security Policy restrictions,
   * the iframe approach may still trigger the Teams protocol handler.
   *
   * If the iframe approach fails, it falls back to the window.open method.
   *
   * Limitations and considerations:
   * 1. Browser security: Some browsers may block protocol handlers in iframes
   * 2. Visual feedback: The iframe remains visible until user interaction
   * 3. Compatibility: May not work in all browsers or with all Teams versions
   *
   * @param {string} url - The Teams URL to open
   */
  function openTeamsUrlSilently(url) {
    logMessage(`Opening Teams URL with visible iframe: ${url}`, "info");

    try {
      // Create a container div for the iframe and close button
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.top = '50%';
      container.style.left = '50%';
      container.style.transform = 'translate(-50%, -50%)';
      container.style.width = '400px';
      container.style.zIndex = '9999';
      container.style.backgroundColor = 'white';
      container.style.borderRadius = '8px';
      container.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
      container.style.overflow = 'hidden';

      // Create a header with instructions and close button
      const header = document.createElement('div');
      header.style.padding = '10px';
      header.style.backgroundColor = '#007bff';
      header.style.color = 'white';
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';

      // Add instructions
      const title = document.createElement('div');
      title.textContent = 'Microsoft Teams Call';
      title.style.fontWeight = 'bold';

      // Create close button
      const closeButton = document.createElement('button');
      closeButton.textContent = '√ó';
      closeButton.style.background = 'none';
      closeButton.style.border = 'none';
      closeButton.style.color = 'white';
      closeButton.style.fontSize = '20px';
      closeButton.style.cursor = 'pointer';
      closeButton.style.padding = '0 5px';

      // Add elements to header
      header.appendChild(title);
      header.appendChild(closeButton);

      // Add instructions below header
      const instructions = document.createElement('div');
      instructions.style.padding = '10px';
      instructions.style.backgroundColor = '#f8f9fa';
      instructions.style.borderBottom = '1px solid #dee2e6';
      instructions.innerHTML = 'Please click <strong>Start Call</strong> in Microsoft Teams.<br>This window will close automatically when you start the call.';

      // Create a visible iframe
      const iframe = document.createElement('iframe');
      iframe.style.width = '100%';
      iframe.style.height = '300px';
      iframe.style.border = 'none';

      // Add elements to container
      container.appendChild(header);
      container.appendChild(instructions);
      container.appendChild(iframe);

      // Add the container to the document
      document.body.appendChild(container);

      // Set the iframe src to the Teams URL
      iframe.src = url;

      logMessage("Visible iframe created to trigger Teams app", "info");
      logMessage("Teams URL opened in visible iframe", "success");

      // Close button event handler
      closeButton.addEventListener('click', () => {
        if (container && container.parentNode) {
          document.body.removeChild(container);
          logMessage("Iframe closed by user", "info");
        }
      });

      // Add a "Call Started" button for the user to click after they've started the call in Teams
      const callStartedButton = document.createElement('button');
      callStartedButton.textContent = 'I\'ve Started the Call';
      callStartedButton.style.width = '100%';
      callStartedButton.style.padding = '10px';
      callStartedButton.style.backgroundColor = '#28a745';
      callStartedButton.style.color = 'white';
      callStartedButton.style.border = 'none';
      callStartedButton.style.borderTop = '1px solid #dee2e6';
      callStartedButton.style.cursor = 'pointer';
      callStartedButton.style.fontWeight = 'bold';

      // Add the button to the container
      container.appendChild(callStartedButton);

      // Call started button event handler
      callStartedButton.addEventListener('click', () => {
        if (container && container.parentNode) {
          document.body.removeChild(container);
          logMessage("Iframe closed after user confirmed call started", "success");
        }
      });

      // Try to detect when Teams has launched
      // This is a best-effort approach as direct detection is limited by browser security
      let teamsLaunchAttempts = 0;
      const maxAttempts = 10;
      const checkTeamsLaunch = setInterval(() => {
        teamsLaunchAttempts++;

        // Check if the iframe has been redirected or blocked
        try {
          // This will throw an error if the iframe has navigated to a different origin
          // due to cross-origin restrictions
          const iframeLocation = iframe.contentWindow.location.href;
          logMessage(`Iframe still accessible at attempt ${teamsLaunchAttempts}`, "info");
        } catch (e) {
          // If we get here, the iframe has likely been redirected to Teams
          logMessage("Teams application may have launched (iframe redirected)", "success");
          // Don't clear the interval yet, as we want to give Teams time to fully launch
        }

        // After max attempts, remind the user to click the button
        if (teamsLaunchAttempts >= maxAttempts) {
          clearInterval(checkTeamsLaunch);

          // Update instructions to prompt user to confirm
          instructions.innerHTML = '<strong>If your call has started in Microsoft Teams, please click the button below.</strong><br>Otherwise, you can close this window using the X button.';
          instructions.style.backgroundColor = '#fff3cd';
          instructions.style.color = '#856404';

          logMessage("Reached maximum attempts to detect Teams launch", "info");
        }
      }, 1000);
    } catch (error) {
      logMessage(`Error using visible iframe: ${error.message}`, "error");

      // Fallback to window.open if the iframe approach fails
      logMessage("Falling back to window.open method", "warning");
      try {
        const teamsWindow = window.open(url, 'teamsCallWindow', 'width=400,height=600');

        if (teamsWindow) {
          logMessage("Teams URL opened in a new window (fallback)", "success");
          teamsWindow.focus();
        } else {
          logMessage("Pop-up blocked. Please allow pop-ups for this site to make Teams calls.", "error");
          alert("Pop-up blocked. Please allow pop-ups for this site to make Teams calls.");
        }
      } catch (fallbackError) {
        logMessage(`Fallback also failed: ${fallbackError.message}`, "error");
        alert("Unable to open Microsoft Teams. Please try again or copy this URL: " + url);
      }
    }
  }

  // Helpers to Enable and Disable Buttons
  function enableButtons(buttons) {
    for (const button of buttons) {
      button.disabled = false;
    }
  }

  function disableButtons(buttons) {
    for (const button of buttons) {
      button.disabled = true;
    }
  }

</script>
</body>
</html>
